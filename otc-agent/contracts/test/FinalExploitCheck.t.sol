// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Test, console} from "forge-std/Test.sol";
import {OTC} from "../contracts/OTC.sol";
import {MockERC20} from "../contracts/MockERC20.sol";
import {MockAggregatorV3} from "../contracts/mocks/MockAggregator.sol";
import {IAggregatorV3} from "../contracts/interfaces/IAggregatorV3.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title FinalExploitCheckTest
 * @notice Final comprehensive checks for edge case exploits
 */
contract FinalExploitCheckTest is Test {
    OTC public otc;
    MockERC20 public token;
    MockERC20 public usdc;
    MockAggregatorV3 public ethFeed;
    MockAggregatorV3 public tokenFeed;
    
    address public owner = address(1);
    address public agent = address(2);
    address public approver = address(3);
    address public consigner = address(4);
    address public buyer = address(5);
    address public attacker = address(6);
    
    bytes32 public tokenId;

    function setUp() public {
        vm.startPrank(owner);
        
        token = new MockERC20("Test", "TST", 18, 100_000_000e18);
        usdc = new MockERC20("USDC", "USDC", 6, 100_000_000e6);
        ethFeed = new MockAggregatorV3(8, 3000e8);
        tokenFeed = new MockAggregatorV3(8, 1e8);
        
        otc = new OTC(owner, IERC20(address(usdc)), IAggregatorV3(address(ethFeed)), agent);
        otc.setApprover(approver, true);
        
        tokenId = keccak256("TST");
        otc.registerToken(tokenId, address(token), address(tokenFeed));
        
        token.transfer(consigner, 10_000_000e18);
        token.transfer(attacker, 10_000_000e18);
        usdc.transfer(buyer, 10_000_000e6);
        usdc.transfer(attacker, 10_000_000e6);
        vm.deal(consigner, 1000 ether);
        vm.deal(buyer, 1000 ether);
        vm.deal(attacker, 1000 ether);
        
        vm.stopPrank();
    }

    /**
     * @notice Verify nonReentrant protects autoClaim loop
     */
    function test_AutoClaimLoopProtected() public {
        // Setup multiple offers
        vm.startPrank(consigner);
        token.approve(address(otc), 10000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 10000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 10000e18, 500
        );
        vm.stopPrank();
        
        // Create multiple offers
        uint256[] memory offerIds = new uint256[](5);
        for (uint i = 0; i < 5; i++) {
            vm.prank(buyer);
            offerIds[i] = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
            
            vm.prank(approver);
            otc.approveOffer(offerIds[i]);
            
            vm.startPrank(buyer);
            usdc.approve(address(otc), 100e6);
            otc.fulfillOffer(offerIds[i]);
            vm.stopPrank();
        }
        
        // AutoClaim all
        vm.prank(approver);
        otc.autoClaim(offerIds);
        
        // All should be fulfilled
        for (uint i = 0; i < 5; i++) {
            (,,,,,,,,,,,,,bool fulfilled,,,) = otc.offers(offerIds[i]);
            assertTrue(fulfilled, "All offers should be fulfilled");
        }
        
        // Buyer should have received all tokens
        assertEq(token.balanceOf(buyer), 500e18, "Buyer received all tokens");
    }

    /**
     * @notice Verify solvency after complex operations
     */
    function test_SolvencyAfterComplexOps() public {
        // Create multiple consignments
        vm.startPrank(consigner);
        token.approve(address(otc), 5000e18);
        
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, true, 0, 0, 0, 1000, 0, 30, 100e18, 1000e18, 500
        );
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 2000e18, true, 0, 0, 0, 1000, 0, 30, 100e18, 2000e18, 500
        );
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 2000e18, true, 0, 0, 0, 1000, 0, 30, 100e18, 2000e18, 500
        );
        vm.stopPrank();
        
        // Create offers from different consignments
        vm.startPrank(buyer);
        uint256 o1 = otc.createOfferFromConsignment(1, 500e18, 0, OTC.PaymentCurrency.USDC, 0);
        uint256 o2 = otc.createOfferFromConsignment(2, 1000e18, 0, OTC.PaymentCurrency.USDC, 0);
        uint256 o3 = otc.createOfferFromConsignment(3, 500e18, 0, OTC.PaymentCurrency.USDC, 0);
        vm.stopPrank();
        
        // Approve and pay some
        vm.prank(approver);
        otc.approveOffer(o1);
        vm.prank(approver);
        otc.approveOffer(o2);
        
        vm.startPrank(buyer);
        usdc.approve(address(otc), 1500e6);
        otc.fulfillOffer(o1);
        otc.fulfillOffer(o2);
        vm.stopPrank();
        
        // Cancel o3
        vm.warp(block.timestamp + 31 minutes);
        vm.prank(buyer);
        otc.cancelOffer(o3);
        
        // Claim o1
        vm.prank(buyer);
        otc.claim(o1);
        
        // Withdraw consignment 3
        vm.prank(consigner);
        otc.withdrawConsignment(3);
        
        // Verify solvency
        uint256 balance = token.balanceOf(address(otc));
        uint256 reserved = otc.tokenReserved(tokenId);
        uint256 deposited = otc.tokenDeposited(tokenId);
        
        console.log("Token balance:", balance);
        console.log("Token reserved:", reserved);
        console.log("Token deposited:", deposited);
        
        assertGe(balance, reserved, "Balance >= Reserved");
        assertGe(deposited, reserved, "Deposited >= Reserved");
        assertGe(balance, deposited, "Balance >= Deposited");
    }

    /**
     * @notice Verify price manipulation protection
     */
    function test_PriceManipulationProtection() public {
        // Create consignment with 5% max volatility (500 bps)
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        // Create offer at current price ($1)
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        // Manipulate price by 2% ($1.02) - within 5% tolerance
        vm.prank(owner);
        tokenFeed.setAnswer(1.02e8);
        
        // Should approve (2% < 5% tolerance)
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        // Create second offer at $1.02
        vm.prank(buyer);
        uint256 offerId2 = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        // Approve second offer at same price
        vm.prank(approver);
        otc.approveOffer(offerId2);
        
        // Now manipulate price by >5% before fulfillment ($1.10 = 10% up from $1)
        vm.prank(owner);
        tokenFeed.setAnswer(1.10e8);
        
        // Try to fulfill - should fail due to price volatility (10% > 5%)
        vm.startPrank(buyer);
        usdc.approve(address(otc), 200e6);
        vm.expectRevert("price volatility exceeded");
        otc.fulfillOffer(offerId);
        vm.stopPrank();
    }

    /**
     * @notice Verify double-spend protection
     */
    function test_DoubleSpendProtection() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        vm.startPrank(buyer);
        usdc.approve(address(otc), 200e6);
        otc.fulfillOffer(offerId);
        
        // Try to fulfill again
        vm.expectRevert("bad state");
        otc.fulfillOffer(offerId);
        vm.stopPrank();
        
        // Claim
        vm.prank(buyer);
        otc.claim(offerId);
        
        // Try to claim again
        vm.prank(buyer);
        vm.expectRevert("bad state");
        otc.claim(offerId);
    }

    /**
     * @notice Verify access control
     */
    function test_AccessControl() public {
        // Non-owner cannot set agent
        vm.prank(attacker);
        vm.expectRevert();
        otc.setAgent(attacker);
        
        // Non-owner cannot register token
        vm.prank(attacker);
        vm.expectRevert();
        otc.registerToken(keccak256("ATTACK"), address(token), address(tokenFeed));
        
        // Non-owner cannot set approver
        vm.prank(attacker);
        vm.expectRevert();
        otc.setApprover(attacker, true);
        
        // Non-owner cannot pause
        vm.prank(attacker);
        vm.expectRevert();
        otc.pause();
        
        // Non-approver cannot approve offers
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        vm.prank(attacker);
        vm.expectRevert("Not approver");
        otc.approveOffer(offerId);
    }

    /**
     * @notice Verify ETH handling edge cases
     */
    function test_ETHHandlingEdgeCases() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.ETH, 0);
        
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        uint256 required = otc.requiredEthWei(offerId);
        
        // Insufficient ETH should fail
        vm.prank(buyer);
        vm.expectRevert("insufficient eth");
        otc.fulfillOffer{value: required - 1}(offerId);
        
        // Exact ETH should work
        uint256 buyerBalBefore = buyer.balance;
        vm.prank(buyer);
        otc.fulfillOffer{value: required}(offerId);
        
        // No refund needed
        assertEq(buyer.balance, buyerBalBefore - required, "Exact payment, no refund");
    }
}

