// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Test, console} from "forge-std/Test.sol";
import {OTC} from "../contracts/OTC.sol";
import {MockERC20} from "../contracts/MockERC20.sol";
import {MockAggregatorV3} from "../contracts/mocks/MockAggregator.sol";
import {IAggregatorV3} from "../contracts/interfaces/IAggregatorV3.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title AdvancedExploitsTest
 * @notice Deep dive into potential exploit scenarios
 */
contract AdvancedExploitsTest is Test {
    OTC public otc;
    MockERC20 public token;
    MockERC20 public usdc;
    MockAggregatorV3 public ethFeed;
    MockAggregatorV3 public tokenFeed;
    
    address public owner = address(1);
    address public agent = address(2);
    address public approver = address(3);
    address public consigner = address(4);
    address public buyer = address(5);
    address public attacker = address(6);
    
    bytes32 public tokenId;

    function setUp() public {
        vm.startPrank(owner);
        
        token = new MockERC20("Test", "TST", 18, 100_000_000e18);
        usdc = new MockERC20("USDC", "USDC", 6, 100_000_000e6);
        ethFeed = new MockAggregatorV3(8, 3000e8);
        tokenFeed = new MockAggregatorV3(8, 1e8);
        
        otc = new OTC(owner, IERC20(address(usdc)), IAggregatorV3(address(ethFeed)), agent);
        otc.setApprover(approver, true);
        
        tokenId = keccak256("TST");
        otc.registerToken(tokenId, address(token), address(tokenFeed));
        
        token.transfer(consigner, 10_000_000e18);
        token.transfer(attacker, 10_000_000e18);
        usdc.transfer(buyer, 10_000_000e6);
        usdc.transfer(attacker, 10_000_000e6);
        vm.deal(consigner, 1000 ether);
        vm.deal(buyer, 1000 ether);
        vm.deal(attacker, 1000 ether);
        
        vm.stopPrank();
    }

    // ============================================================
    // EXPLOIT ATTEMPT #1: Sandwich Attack on Approval
    // ============================================================
    
    /**
     * @notice Attempt sandwich attack on approval
     * @dev Attacker watches mempool, front-runs approval with price manipulation
     * Result: Protected by maxPriceDeviation check
     */
    function test_EXPLOIT_SandwichApprovalBlocked() public {
        // Setup: Consigner creates consignment with 1% max volatility
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 100);
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        // Attacker manipulates price after approval (5% drop)
        vm.prank(owner);
        tokenFeed.setAnswer(0.95e8);
        
        // Fulfillment should fail
        vm.startPrank(buyer);
        usdc.approve(address(otc), 100e6);
        vm.expectRevert("price volatility exceeded");
        otc.fulfillOffer(offerId);
        vm.stopPrank();
    }

    // ============================================================
    // EXPLOIT ATTEMPT #3: Token Amount Manipulation
    // ============================================================
    
    /**
     * @notice Attempt to claim more tokens than paid for
     * @dev Each offer has fixed tokenAmount - cannot be manipulated after creation
     */
    function test_EXPLOIT_CannotClaimMoreThanPaid() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        // Buyer pays for 100 tokens
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        vm.startPrank(buyer);
        usdc.approve(address(otc), 100e6);
        otc.fulfillOffer(offerId);
        
        // Claim
        otc.claim(offerId);
        vm.stopPrank();
        
        // Buyer can only get 100 tokens
        assertEq(token.balanceOf(buyer), 100e18, "Buyer got exactly what was paid for");
        
        // Cannot claim again
        vm.prank(buyer);
        vm.expectRevert("bad state");
        otc.claim(offerId);
    }

    // ============================================================
    // EXPLOIT ATTEMPT #4: Consignment Draining via Multiple Offers
    // ============================================================
    
    /**
     * @notice Attempt to drain consignment by creating more offers than tokens available
     * @dev Protected by remainingAmount check
     */
    function test_EXPLOIT_CannotOverReserveConsignment() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 500e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 500e18, false, 0, 0, 0, 0, 0, 0, 100e18, 500e18, 500
        );
        vm.stopPrank();
        
        // Create offers totaling 500 tokens
        vm.startPrank(buyer);
        otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        // 6th offer should fail - consignment is inactive (all tokens reserved)
        vm.expectRevert("consignment not active");
        otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        vm.stopPrank();
        
        // Verify consignment is depleted
        (,,, uint256 remaining,,,,,,,,,,,bool active,) = otc.consignments(1);
        assertEq(remaining, 0, "No tokens remaining");
        assertFalse(active, "Consignment inactive");
    }

    // ============================================================
    // EXPLOIT ATTEMPT #5: Replay Attack on Offers
    // ============================================================
    
    /**
     * @notice Attempt to replay/reuse an offer
     * @dev Protected by state flags (paid, fulfilled, cancelled)
     */
    function test_EXPLOIT_CannotReplayOffer() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        vm.startPrank(buyer);
        usdc.approve(address(otc), 200e6); // Approve more than needed
        
        // First payment
        otc.fulfillOffer(offerId);
        
        // Second payment attempt - should fail
        vm.expectRevert("bad state");
        otc.fulfillOffer(offerId);
        
        // Claim
        otc.claim(offerId);
        
        // Claim again - should fail
        vm.expectRevert("bad state");
        otc.claim(offerId);
        vm.stopPrank();
    }

    // ============================================================
    // EXPLOIT ATTEMPT #6: Race Condition in Approval
    // ============================================================
    
    /**
     * @notice Test for race conditions in multi-approval system
     * @dev Same approver cannot approve twice
     */
    function test_EXPLOIT_CannotDoubleApprove() public {
        // Setup 2-of-3 multi-sig approval
        vm.startPrank(owner);
        otc.setRequiredApprovals(2);
        address approver2 = address(10);
        address approver3 = address(11);
        otc.setApprover(approver2, true);
        otc.setApprover(approver3, true);
        vm.stopPrank();
        
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        // First approval
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        // Same approver tries again - should fail
        vm.prank(approver);
        vm.expectRevert("already approved by you");
        otc.approveOffer(offerId);
        
        // Different approver succeeds
        vm.prank(approver2);
        otc.approveOffer(offerId);
        
        // Now offer is approved
        (,,,,,,,,,,, bool approved,,,,,) = otc.offers(offerId);
        assertTrue(approved, "Offer approved with 2 signatures");
    }

    // ============================================================
    // EXPLOIT ATTEMPT #7: Stale Price Exploitation
    // ============================================================
    
    /**
     * @notice Attempt to exploit stale price feed
     * @dev Protected by maxFeedAgeSeconds check
     */
    function test_EXPLOIT_StalePriceBlocked() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        // Create offer at current timestamp
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        // Warp past max feed age (1 hour by default)
        vm.warp(block.timestamp + 2 hours);
        
        // Approval should fail due to stale price
        vm.prank(approver);
        vm.expectRevert("stale price");
        otc.approveOffer(offerId);
    }

    // ============================================================
    // EXPLOIT ATTEMPT #8: Zero Token Attack
    // ============================================================
    
    /**
     * @notice Attempt to create offers with zero or invalid amounts
     * @dev Protected by amount validation
     */
    function test_EXPLOIT_ZeroAmountBlocked() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        // Try to create offer with 0 tokens - fails minDealAmount check
        vm.prank(buyer);
        vm.expectRevert("amount out of range");
        otc.createOfferFromConsignment(1, 0, 0, OTC.PaymentCurrency.USDC, 0);
        
        // Try below minimum deal amount
        vm.prank(buyer);
        vm.expectRevert("amount out of range");
        otc.createOfferFromConsignment(1, 50e18, 0, OTC.PaymentCurrency.USDC, 0);
    }

    // ============================================================
    // EXPLOIT ATTEMPT #9: Consignment Withdrawal After Offers
    // ============================================================
    
    /**
     * @notice Attempt to withdraw consignment while offers are pending
     * @dev Only remaining (unreserved) tokens can be withdrawn
     */
    function test_EXPLOIT_CannotWithdrawReservedTokens() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        // Create offer reserving 500 tokens
        vm.prank(buyer);
        otc.createOfferFromConsignment(1, 500e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        // Consigner tries to withdraw - can only get unreserved portion
        // Actually, withdrawConsignment takes ALL remaining tokens
        // But remaining is 500 (after 500 reserved)
        uint256 consignerBalBefore = token.balanceOf(consigner);
        
        vm.prank(consigner);
        otc.withdrawConsignment(1);
        
        // Only got 500 tokens back (the unreserved portion)
        assertEq(token.balanceOf(consigner), consignerBalBefore + 500e18, "Got unreserved tokens");
        
        // Contract still holds reserved 500
        assertEq(token.balanceOf(address(otc)), 500e18, "Reserved tokens remain");
    }

    // ============================================================
    // EXPLOIT ATTEMPT #10: Approval After Cancellation
    // ============================================================
    
    /**
     * @notice Attempt to approve a cancelled offer
     * @dev Protected by state check in approveOffer
     */
    function test_EXPLOIT_CannotApproveCancelledOffer() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        // Approver cancels
        vm.prank(approver);
        otc.cancelOffer(offerId);
        
        // Attempt to approve cancelled offer
        vm.prank(approver);
        vm.expectRevert("bad state");
        otc.approveOffer(offerId);
    }

    // ============================================================
    // EXPLOIT ATTEMPT #11: Withdraw Gas Deposits from Active Consignment
    // ============================================================
    
    /**
     * @notice Attempt to withdraw gas deposit from active consignment
     * @dev Only inactive consignments allow gas withdrawal
     */
    function test_EXPLOIT_CannotWithdrawGasFromActive() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        // Try to withdraw gas from active consignment
        uint256[] memory ids = new uint256[](1);
        ids[0] = 1;
        
        // Should fail - no gas to withdraw (consignment is active)
        vm.prank(agent);
        vm.expectRevert("no gas deposits to withdraw");
        otc.withdrawGasDeposits(ids);
    }

    // ============================================================
    // EXPLOIT ATTEMPT #12: ETH Payment Underpayment
    // ============================================================
    
    /**
     * @notice Attempt to underpay with ETH
     * @dev Protected by strict amount check
     */
    function test_EXPLOIT_CannotUnderpayETH() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.ETH, 0);
        
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        uint256 required = otc.requiredEthWei(offerId);
        
        // Underpayment
        vm.prank(buyer);
        vm.expectRevert("insufficient eth");
        otc.fulfillOffer{value: required - 1}(offerId);
        
        // Exact payment
        vm.prank(buyer);
        otc.fulfillOffer{value: required}(offerId);
    }

    // ============================================================
    // EXPLOIT ATTEMPT #13: USDC Approval Manipulation
    // ============================================================
    
    /**
     * @notice Attempt to manipulate USDC approval during fulfillment
     * @dev Protected by safeTransferFrom
     */
    function test_EXPLOIT_USDCApprovalRequired() public {
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 0, 0, 0, 0, 0, 0, 100e18, 1000e18, 500
        );
        vm.stopPrank();
        
        vm.prank(buyer);
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 0, OTC.PaymentCurrency.USDC, 0);
        
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        // Without approval, should fail
        vm.prank(buyer);
        vm.expectRevert();
        otc.fulfillOffer(offerId);
        
        // With approval
        vm.startPrank(buyer);
        usdc.approve(address(otc), 100e6);
        otc.fulfillOffer(offerId);
        vm.stopPrank();
    }

    // ============================================================
    // EXPLOIT ATTEMPT #14: Self-Dealing as Consigner
    // ============================================================
    
    /**
     * @notice Test if consigner can self-deal (buy their own tokens at discount)
     * @dev This is allowed by design - consigner can create and buy own consignment
     */
    function test_EDGE_ConsignerCanSelfDeal() public {
        // Consigner deposits tokens
        vm.startPrank(consigner);
        token.approve(address(otc), 1000e18);
        otc.createConsignment{value: 0.001 ether}(
            tokenId, 1000e18, false, 
            1000, 0, // 10% discount, no lockup
            0, 0, 0, 0, 100e18, 1000e18, 500
        );
        
        // Consigner also buys from their own consignment
        uint256 offerId = otc.createOfferFromConsignment(1, 100e18, 1000, OTC.PaymentCurrency.USDC, 0);
        vm.stopPrank();
        
        vm.prank(approver);
        otc.approveOffer(offerId);
        
        // Give consigner USDC for payment
        vm.prank(owner);
        usdc.transfer(consigner, 100e6);
        
        // Consigner pays discounted price
        vm.startPrank(consigner);
        usdc.approve(address(otc), 100e6);
        otc.fulfillOffer(offerId);
        otc.claim(offerId);
        vm.stopPrank();
        
        // This is allowed - consigner is both seller and buyer
        // They paid 90% of value, got tokens back
        // Net: lost 10% to fees (paid to protocol in USDC)
        console.log("Self-dealing allowed but costs consigner the discount as USDC payment");
    }
}

/**
 * @title AccountingSolvencyTest
 * @notice Verify accounting invariants hold across complex scenarios
 */
contract AccountingSolvencyTest is Test {
    OTC public otc;
    MockERC20 public token;
    MockERC20 public usdc;
    MockAggregatorV3 public ethFeed;
    MockAggregatorV3 public tokenFeed;
    
    address public owner = address(1);
    address public agent = address(2);
    address public approver = address(3);
    address[] public consigners;
    address[] public buyers;
    
    bytes32 public tokenId;

    function setUp() public {
        vm.startPrank(owner);
        
        token = new MockERC20("Test", "TST", 18, 100_000_000e18);
        usdc = new MockERC20("USDC", "USDC", 6, 100_000_000e6);
        ethFeed = new MockAggregatorV3(8, 3000e8);
        tokenFeed = new MockAggregatorV3(8, 1e8);
        
        otc = new OTC(owner, IERC20(address(usdc)), IAggregatorV3(address(ethFeed)), agent);
        otc.setApprover(approver, true);
        
        tokenId = keccak256("TST");
        otc.registerToken(tokenId, address(token), address(tokenFeed));
        
        // Setup multiple users
        for (uint i = 0; i < 5; i++) {
            address c = address(uint160(100 + i));
            address b = address(uint160(200 + i));
            consigners.push(c);
            buyers.push(b);
            
            token.transfer(c, 100_000e18);
            usdc.transfer(b, 100_000e6);
            vm.deal(c, 10 ether);
            vm.deal(b, 10 ether);
        }
        
        vm.stopPrank();
    }

    /**
     * @notice Complex scenario with multiple users
     */
    function test_AccountingComplexScenario() public {
        // Multiple consigners create consignments
        for (uint i = 0; i < 5; i++) {
            vm.startPrank(consigners[i]);
            token.approve(address(otc), 10000e18);
            otc.createConsignment{value: 0.001 ether}(
                tokenId, 10000e18, true, 0, 0, 0, 1000, 0, 30, 100e18, 10000e18, 500
            );
            vm.stopPrank();
        }
        
        // Total deposited: 50000
        assertEq(otc.tokenDeposited(tokenId), 50000e18, "Total deposited correct");
        
        // Multiple buyers create offers
        uint256[] memory offerIds = new uint256[](10);
        for (uint i = 0; i < 10; i++) {
            vm.prank(buyers[i % 5]);
            offerIds[i] = otc.createOfferFromConsignment((i % 5) + 1, 1000e18, 0, OTC.PaymentCurrency.USDC, 0);
        }
        
        // Total reserved: 10000
        assertEq(otc.tokenReserved(tokenId), 10000e18, "Total reserved correct");
        
        // Approve and pay some
        for (uint i = 0; i < 5; i++) {
            vm.prank(approver);
            otc.approveOffer(offerIds[i]);
            
            vm.startPrank(buyers[i]);
            usdc.approve(address(otc), 1000e6);
            otc.fulfillOffer(offerIds[i]);
            vm.stopPrank();
        }
        
        // Claim some
        for (uint i = 0; i < 3; i++) {
            vm.prank(buyers[i]);
            otc.claim(offerIds[i]);
        }
        
        // Cancel some
        vm.warp(block.timestamp + 31 minutes);
        for (uint i = 5; i < 8; i++) {
            vm.prank(buyers[i % 5]);
            otc.cancelOffer(offerIds[i]);
        }
        
        // Withdraw one consignment
        vm.prank(consigners[0]);
        otc.withdrawConsignment(1);
        
        // Check solvency
        uint256 balance = token.balanceOf(address(otc));
        uint256 reserved = otc.tokenReserved(tokenId);
        uint256 deposited = otc.tokenDeposited(tokenId);
        
        console.log("Final state:");
        console.log("  Balance:", balance);
        console.log("  Reserved:", reserved);
        console.log("  Deposited:", deposited);
        
        // Balance should cover all reserved tokens
        assertGe(balance, reserved, "Balance >= Reserved");
        
        // Deposited should be >= reserved (some may be unreserved)
        assertGe(deposited, reserved, "Deposited >= Reserved");
    }
}

