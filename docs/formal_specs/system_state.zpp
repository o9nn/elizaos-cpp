--------------------------------------------------------------------------------
-- ElizaOS C++ System State Formal Specification
-- Z++ Specification Language
-- Version: 1.0.0
-- Date: December 12, 2024
--------------------------------------------------------------------------------

-- This specification formalizes the system state of the ElizaOS C++ framework,
-- including agent state, memory state, communication state, and global invariants.

-- Import data model definitions
-- include data_model.zpp

--------------------------------------------------------------------------------
-- AGENT STATE
--------------------------------------------------------------------------------

-- Individual agent state
schema AgentState
  config: AgentConfig
  status: AgentStatus
  currentMemories: seq Memory
  actors: seq Actor
  goals: seq Goal
  recentMessages: seq Memory
  characterProfile: ‚Ñô CharacterProfile
  conversationContexts: UUID ‚á∏ ConversationContext
  knowledgeReferences: ‚Ñô UUID
  activeTaskIds: ‚Ñô UUID
  lastActivity: Timestamp
  cognitiveLoad: ‚Ñù
  attentionFocus: ‚Ñô UUID  -- Currently focused memory/knowledge IDs
where
  -- Agent ID must match config
  config.agentId ‚àà AgentId
  
  -- Recent messages should not exceed maximum (e.g., 32)
  #recentMessages ‚â§ 32
  
  -- Optional character profile
  #characterProfile ‚â§ 1
  
  -- Cognitive load must be in [0, 1] range
  0 ‚â§ cognitiveLoad ‚â§ 1
  
  -- Recent messages must be chronologically ordered
  ‚àÄ i, j: dom recentMessages | i < j ‚Ä¢ 
    (recentMessages(i)).createdAt ‚â§ (recentMessages(j)).createdAt
  
  -- All conversation contexts must have unique session IDs
  ‚àÄ sid1, sid2: dom conversationContexts | sid1 ‚â† sid2 ‚Ä¢
    (conversationContexts(sid1)).sessionId ‚â† (conversationContexts(sid2)).sessionId
  
  -- Actor IDs must be unique
  ‚àÄ i, j: dom actors | i ‚â† j ‚Ä¢ 
    (actors(i)).id ‚â† (actors(j)).id
  
  -- Goal IDs must be unique
  ‚àÄ i, j: dom goals | i ‚â† j ‚Ä¢ 
    (goals(i)).id ‚â† (goals(j)).id
end

-- Agent loop execution state
schema AgentLoopState
  agentId: AgentId
  running: ùîπ
  paused: ùîπ
  stepIndex: ‚Ñï
  totalSteps: ‚Ñï
  intervalSeconds: ‚Ñù
  lastExecutionTime: ‚Ñô Timestamp
  errorCount: ‚Ñï
  executionHistory: seq Timestamp
where
  -- Step index must be within bounds
  stepIndex ‚â§ totalSteps
  
  -- Interval must be non-negative
  intervalSeconds ‚â• 0
  
  -- Optional last execution time
  #lastExecutionTime ‚â§ 1
  
  -- If paused, must not be running
  paused ‚áí ¬¨running
  
  -- Execution history must be chronologically ordered
  ‚àÄ i, j: dom executionHistory | i < j ‚Ä¢ 
    executionHistory(i) ‚â§ executionHistory(j)
end

--------------------------------------------------------------------------------
-- MEMORY SYSTEM STATE
--------------------------------------------------------------------------------

-- Memory storage state for a single table
schema MemoryTableState
  tableName: Content
  memories: UUID ‚á∏ Memory
  embeddingIndex: UUID ‚á∏ EmbeddingVector
  roomIndex: RoomId ‚á∏ ‚Ñô UUID
  agentIndex: AgentId ‚á∏ ‚Ñô UUID
  entityIndex: EntityId ‚á∏ ‚Ñô UUID
  worldIndex: WorldId ‚á∏ ‚Ñô UUID
where
  -- Table name must not be empty
  #tableName > 0
  
  -- All memory IDs in indices must exist in memories
  dom embeddingIndex ‚äÜ dom memories
  ‚ãÉ ran roomIndex ‚äÜ dom memories
  ‚ãÉ ran agentIndex ‚äÜ dom memories
  ‚ãÉ ran entityIndex ‚äÜ dom memories
  ‚ãÉ ran worldIndex ‚äÜ dom memories
  
  -- Embedding index contains only memories with embeddings
  ‚àÄ id: dom embeddingIndex ‚Ä¢ 
    (memories(id)).embedding ‚â† ‚àÖ
  
  -- Room index correctly maps rooms to memory IDs
  ‚àÄ rid: dom roomIndex ‚Ä¢ ‚àÄ mid: roomIndex(rid) ‚Ä¢ 
    (memories(mid)).roomId ‚â† ‚àÖ ‚àß (‚ãÉ (memories(mid)).roomId) = rid
  
  -- Agent index correctly maps agents to memory IDs
  ‚àÄ aid: dom agentIndex ‚Ä¢ ‚àÄ mid: agentIndex(aid) ‚Ä¢ 
    (memories(mid)).agentId = aid
  
  -- Entity index correctly maps entities to memory IDs
  ‚àÄ eid: dom entityIndex ‚Ä¢ ‚àÄ mid: entityIndex(eid) ‚Ä¢ 
    (memories(mid)).entityId = eid
end

-- Complete memory system state
schema MemorySystemState
  tables: Content ‚á∏ MemoryTableState
  embeddingDimension: ‚Ñï
  totalMemories: ‚Ñï
  attentionThreshold: ‚Ñù
  maxMemoriesPerTable: ‚Ñï
where
  -- Must have at least the default "memories" table
  "memories" ‚àà dom tables
  
  -- Embedding dimension must be positive if set
  embeddingDimension > 0
  
  -- Total memories equals sum of memories in all tables
  totalMemories = (Œ£ t: dom tables ‚Ä¢ #((tables(t)).memories))
  
  -- Attention threshold must be in [0, 1]
  0 ‚â§ attentionThreshold ‚â§ 1
  
  -- Max memories must be positive
  maxMemoriesPerTable > 0
  
  -- No table should exceed max memories
  ‚àÄ t: dom tables ‚Ä¢ 
    #((tables(t)).memories) ‚â§ maxMemoriesPerTable
  
  -- All table names must be non-empty
  ‚àÄ t: dom tables ‚Ä¢ 
    #((tables(t)).tableName) > 0
end

--------------------------------------------------------------------------------
-- COMMUNICATION SYSTEM STATE
--------------------------------------------------------------------------------

-- Channel state
schema ChannelState
  channelId: ChannelId
  name: Content
  serverId: ServerId
  participants: ‚Ñô AgentId
  messageQueue: seq Message
  messageHistory: seq UUID  -- Message IDs
  isActive: ùîπ
  createdAt: Timestamp
where
  -- Channel ID and name must not be empty
  channelId ‚àà ChannelId
  #name > 0
  
  -- Message queue should be bounded
  #messageQueue ‚â§ 1000
  
  -- All queued messages must have correct channel ID
  ‚àÄ m: ran messageQueue ‚Ä¢ 
    m.channelId = channelId
  
  -- Message IDs in history must be unique
  #(‚ãÉ ran messageHistory) = #messageHistory
end

-- Server state
schema ServerState
  serverId: ServerId
  name: Content
  channels: ‚Ñô ChannelId
  agents: ‚Ñô AgentId
  isActive: ùîπ
  createdAt: Timestamp
where
  -- Server ID and name must not be empty
  serverId ‚àà ServerId
  #name > 0
  
  -- Server must have at least one channel if active
  isActive ‚áí channels ‚â† ‚àÖ
end

-- Agent participation tracking
schema AgentParticipationState
  agentId: AgentId
  subscribedServers: ‚Ñô ServerId
  subscribedChannels: ‚Ñô ChannelId
  unreadMessages: ChannelId ‚á∏ ‚Ñï
  lastActivity: Timestamp
where
  -- Unread count must be non-negative
  ‚àÄ cid: dom unreadMessages ‚Ä¢ 
    unreadMessages(cid) ‚â• 0
  
  -- Can only have unread messages for subscribed channels
  dom unreadMessages ‚äÜ subscribedChannels
end

-- Complete communication system state
schema CommunicationSystemState
  channels: ChannelId ‚á∏ ChannelState
  servers: ServerId ‚á∏ ServerState
  agents: AgentId ‚á∏ AgentParticipationState
  messageArchive: UUID ‚á∏ Message
  pendingMessages: seq Message
  messageValidationErrors: ‚Ñï
where
  -- All channel IDs in servers must exist
  ‚àÄ s: ran servers ‚Ä¢ 
    s.channels ‚äÜ dom channels
  
  -- All server IDs in channels must exist
  ‚àÄ c: ran channels ‚Ä¢ 
    c.serverId ‚àà dom servers
  
  -- Agent participation must be consistent with servers
  ‚àÄ a: ran agents ‚Ä¢ 
    ‚àÄ sid: a.subscribedServers ‚Ä¢ 
      sid ‚àà dom servers ‚àß a.agentId ‚àà (servers(sid)).agents
  
  -- Agent participation must be consistent with channels
  ‚àÄ a: ran agents ‚Ä¢ 
    ‚àÄ cid: a.subscribedChannels ‚Ä¢ 
      cid ‚àà dom channels ‚àß a.agentId ‚àà (channels(cid)).participants
  
  -- All messages in archive must have unique IDs
  ‚àÄ m1, m2: ran messageArchive | m1 ‚â† m2 ‚Ä¢ 
    m1.id ‚â† m2.id
  
  -- Pending messages queue should be bounded
  #pendingMessages ‚â§ 10000
  
  -- Validation error count must be non-negative
  messageValidationErrors ‚â• 0
end

--------------------------------------------------------------------------------
-- KNOWLEDGE SYSTEM STATE
--------------------------------------------------------------------------------

-- Knowledge base entry state
schema KnowledgeEntry
  id: UUID
  content: Content
  category: Content
  embedding: ‚Ñô EmbeddingVector
  metadata: Content ‚Üî Content
  references: seq UUID  -- References to other knowledge entries
  createdAt: Timestamp
  updatedAt: Timestamp
  accessCount: ‚Ñï
  lastAccessed: ‚Ñô Timestamp
where
  -- Content must not be empty
  #content > 0
  
  -- Category must not be empty
  #category > 0
  
  -- Optional embedding
  #embedding ‚â§ 1
  
  -- Timestamps must be ordered
  createdAt ‚â§ updatedAt
  
  -- Access count must be non-negative
  accessCount ‚â• 0
  
  -- Optional last accessed time
  #lastAccessed ‚â§ 1
  
  -- If accessed, last accessed time must be after creation
  lastAccessed ‚â† ‚àÖ ‚áí createdAt ‚â§ (‚ãÉ lastAccessed)
  
  -- Reference IDs must be unique
  #(‚ãÉ ran references) = #references
end

-- Knowledge system state
schema KnowledgeSystemState
  entries: UUID ‚á∏ KnowledgeEntry
  categoryIndex: Content ‚á∏ ‚Ñô UUID
  embeddingIndex: UUID ‚á∏ EmbeddingVector
  referenceGraph: UUID ‚á∏ ‚Ñô UUID
  totalEntries: ‚Ñï
where
  -- Total entries matches actual count
  totalEntries = #entries
  
  -- Category index correctly maps categories to entry IDs
  ‚àÄ cat: dom categoryIndex ‚Ä¢ ‚àÄ eid: categoryIndex(cat) ‚Ä¢ 
    eid ‚àà dom entries ‚àß (entries(eid)).category = cat
  
  -- Embedding index contains only entries with embeddings
  ‚àÄ eid: dom embeddingIndex ‚Ä¢ 
    eid ‚àà dom entries ‚àß (entries(eid)).embedding ‚â† ‚àÖ
  
  -- Reference graph correctly reflects entry references
  ‚àÄ eid: dom referenceGraph ‚Ä¢ 
    eid ‚àà dom entries ‚àß 
    referenceGraph(eid) = (‚ãÉ ran ((entries(eid)).references))
  
  -- All referenced entries must exist (referential integrity)
  ‚àÄ eid: dom entries ‚Ä¢ 
    ‚àÄ refid: ran ((entries(eid)).references) ‚Ä¢ 
      refid ‚àà dom entries
end

--------------------------------------------------------------------------------
-- HYPERGRAPH STATE
--------------------------------------------------------------------------------

-- Hypergraph state for knowledge representation
schema HypergraphState
  nodes: UUID ‚á∏ HypergraphNode
  edges: UUID ‚á∏ HypergraphEdge
  nodeIndex: Content ‚á∏ ‚Ñô UUID  -- Label to node IDs
  totalNodes: ‚Ñï
  totalEdges: ‚Ñï
  attentionBudget: ‚Ñù  -- Total STI budget
  forgettingThreshold: ‚Ñù  -- Minimum STI to keep in memory
where
  -- Totals match actual counts
  totalNodes = #nodes
  totalEdges = #edges
  
  -- Node index correctly maps labels to node IDs
  ‚àÄ label: dom nodeIndex ‚Ä¢ ‚àÄ nid: nodeIndex(label) ‚Ä¢ 
    nid ‚àà dom nodes ‚àß (nodes(nid)).label = label
  
  -- All edges reference existing nodes
  ‚àÄ e: ran edges ‚Ä¢ 
    ‚àÄ nid: ran (e.nodeIds) ‚Ä¢ 
      nid ‚àà dom nodes
  
  -- Attention budget must be positive
  attentionBudget > 0
  
  -- Forgetting threshold must be in [0, 1]
  0 ‚â§ forgettingThreshold ‚â§ 1
  
  -- Total STI across all nodes and edges should not exceed budget * 2
  (Œ£ n: ran nodes ‚Ä¢ n.sti) + (Œ£ e: ran edges ‚Ä¢ e.sti) ‚â§ attentionBudget * 2
end

--------------------------------------------------------------------------------
-- TASK MANAGEMENT STATE
--------------------------------------------------------------------------------

-- Task manager state
schema TaskManagerState
  tasks: UUID ‚á∏ Task
  tasksByStatus: TaskStatus ‚á∏ ‚Ñô UUID
  tasksByPriority: seq UUID  -- Sorted by priority
  taskDependencies: UUID ‚á∏ ‚Ñô UUID
  executingTasks: ‚Ñô UUID
  completedTasks: ‚Ñô UUID
  failedTasks: ‚Ñô UUID
  totalTasks: ‚Ñï
where
  -- Total tasks matches actual count
  totalTasks = #tasks
  
  -- Status index correctly maps status to task IDs
  ‚àÄ status: dom tasksByStatus ‚Ä¢ ‚àÄ tid: tasksByStatus(status) ‚Ä¢ 
    tid ‚àà dom tasks ‚àß (tasks(tid)).status = status
  
  -- All task IDs in priority list must exist
  ‚ãÉ ran tasksByPriority ‚äÜ dom tasks
  
  -- Priority list must be sorted by descending priority
  ‚àÄ i, j: dom tasksByPriority | i < j ‚Ä¢ 
    (tasks(tasksByPriority(i))).priority ‚â• (tasks(tasksByPriority(j))).priority
  
  -- Task dependencies correctly reflect task.dependencies
  ‚àÄ tid: dom taskDependencies ‚Ä¢ 
    tid ‚àà dom tasks ‚àß 
    taskDependencies(tid) = (‚ãÉ ran ((tasks(tid)).dependencies))
  
  -- Executing tasks must be subset of all tasks
  executingTasks ‚äÜ dom tasks
  
  -- Executing tasks must have IN_PROGRESS status
  ‚àÄ tid: executingTasks ‚Ä¢ 
    (tasks(tid)).status = IN_PROGRESS
  
  -- Completed and failed tasks must not overlap
  completedTasks ‚à© failedTasks = ‚àÖ
  
  -- Completed tasks must have COMPLETED status
  ‚àÄ tid: completedTasks ‚Ä¢ 
    (tasks(tid)).status = COMPLETED
  
  -- Failed tasks must have FAILED status
  ‚àÄ tid: failedTasks ‚Ä¢ 
    (tasks(tid)).status = FAILED
end

--------------------------------------------------------------------------------
-- GLOBAL SYSTEM STATE
--------------------------------------------------------------------------------

-- Complete ElizaOS system state
schema ElizaOSSystemState
  agents: AgentId ‚á∏ AgentState
  agentLoops: AgentId ‚á∏ AgentLoopState
  memorySystem: MemorySystemState
  communicationSystem: CommunicationSystemState
  knowledgeSystem: KnowledgeSystemState
  hypergraph: HypergraphState
  taskManager: TaskManagerState
  systemStartTime: Timestamp
  systemUptime: ‚Ñù
  totalProcessedMessages: ‚Ñï
  totalMemoriesCreated: ‚Ñï
  threadCount: ‚Ñï
where
  -- All agent IDs in loops must exist in agents
  dom agentLoops ‚äÜ dom agents
  
  -- All agent IDs in communication must exist in agents
  dom (communicationSystem.agents) ‚äÜ dom agents
  
  -- System uptime must be non-negative
  systemUptime ‚â• 0
  
  -- Total messages must be non-negative
  totalProcessedMessages ‚â• 0
  
  -- Total memories must match memory system
  totalMemoriesCreated ‚â• memorySystem.totalMemories
  
  -- Thread count must be positive
  threadCount > 0
  
  -- Active agent loops must have running or paused status
  ‚àÄ aid: dom agentLoops ‚Ä¢ 
    (agentLoops(aid)).running ‚à® (agentLoops(aid)).paused
  
  -- All agent task references must exist in task manager
  ‚àÄ a: ran agents ‚Ä¢ 
    a.activeTaskIds ‚äÜ dom (taskManager.tasks)
end

--------------------------------------------------------------------------------
-- SYSTEM STATE INVARIANTS
--------------------------------------------------------------------------------

-- System consistency invariant
schema SystemConsistency
  ElizaOSSystemState
where
  -- Memory system total matches sum across all tables
  memorySystem.totalMemories = 
    (Œ£ t: dom (memorySystem.tables) ‚Ä¢ 
      #(((memorySystem.tables)(t)).memories))
  
  -- All agent recent messages must exist in memory system
  ‚àÄ a: ran agents ‚Ä¢ ‚àÄ m: ran (a.recentMessages) ‚Ä¢ 
    ‚àÉ t: dom (memorySystem.tables) ‚Ä¢ 
      m.id ‚àà dom ((memorySystem.tables(t)).memories)
  
  -- All conversation contexts must reference existing agents
  ‚àÄ a: ran agents ‚Ä¢ ‚àÄ ctx: ran (a.conversationContexts) ‚Ä¢ 
    ctx.userId ‚àà dom agents
  
  -- Knowledge references in agents must exist
  ‚àÄ a: ran agents ‚Ä¢ 
    a.knowledgeReferences ‚äÜ dom (knowledgeSystem.entries)
end

-- Resource constraints invariant
schema ResourceConstraints
  ElizaOSSystemState
where
  -- Total memory usage should not exceed maximum
  memorySystem.totalMemories ‚â§ 
    memorySystem.maxMemoriesPerTable * #(memorySystem.tables)
  
  -- Thread count should not exceed reasonable maximum
  threadCount ‚â§ 1000
  
  -- Total pending messages should not exceed queue limits
  #(communicationSystem.pendingMessages) ‚â§ 10000
  
  -- No agent should have excessive recent messages
  ‚àÄ a: ran agents ‚Ä¢ 
    #(a.recentMessages) ‚â§ 32
  
  -- Task manager should not have excessive tasks
  taskManager.totalTasks ‚â§ 100000
end

-- Thread safety invariant
schema ThreadSafetyInvariant
  ElizaOSSystemState
where
  -- All mutations to shared state must be protected by locks
  -- (This is an abstract specification; actual implementation uses mutexes)
  
  -- Multiple threads can read the same data concurrently
  -- Only one thread can write to any given data at a time
  
  -- Agent states are independent and can be accessed concurrently
  ‚àÄ a1, a2: dom agents | a1 ‚â† a2 ‚Ä¢ true
  -- (No interference between different agent states)
end

--------------------------------------------------------------------------------
-- INITIAL STATE
--------------------------------------------------------------------------------

-- Initial system state when ElizaOS starts
schema InitialElizaOSState
  ElizaOSSystemState
where
  -- No agents initially
  agents = ‚àÖ
  agentLoops = ‚àÖ
  
  -- Memory system initialized with default table
  dom (memorySystem.tables) = {"memories"}
  memorySystem.totalMemories = 0
  
  -- Communication system empty
  communicationSystem.channels = ‚àÖ
  communicationSystem.servers = ‚àÖ
  communicationSystem.agents = ‚àÖ
  
  -- Knowledge system empty
  knowledgeSystem.totalEntries = 0
  
  -- Hypergraph empty
  hypergraph.totalNodes = 0
  hypergraph.totalEdges = 0
  
  -- Task manager empty
  taskManager.totalTasks = 0
  
  -- System counters at zero
  totalProcessedMessages = 0
  totalMemoriesCreated = 0
  
  -- Minimum thread count
  threadCount = 1
  
  -- System uptime is zero
  systemUptime = 0
end

--------------------------------------------------------------------------------
-- END OF SYSTEM STATE SPECIFICATION
--------------------------------------------------------------------------------

-- This specification defines the complete system state of ElizaOS C++,
-- including all subsystem states and global invariants. Operations will
-- be defined as state transformations in the operations specification.
