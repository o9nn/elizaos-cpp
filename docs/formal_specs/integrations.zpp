--------------------------------------------------------------------------------
-- ElizaOS C++ Integration Contracts Formal Specification
-- Z++ Specification Language
-- Version: 1.0.0
-- Date: December 12, 2024
--------------------------------------------------------------------------------

-- This specification formalizes external system integrations for ElizaOS C++,
-- including API contracts, event handlers, and error handling.

-- Import previous specifications
-- include data_model.zpp
-- include system_state.zpp
-- include operations.zpp

--------------------------------------------------------------------------------
-- EXTERNAL API TYPES
--------------------------------------------------------------------------------

-- HTTP request types
HTTPMethod ::= GET | POST | PUT | DELETE | PATCH

-- HTTP status codes
HTTPStatus ::= OK | CREATED | BAD_REQUEST | UNAUTHORIZED | 
               FORBIDDEN | NOT_FOUND | SERVER_ERROR

-- API request structure
schema APIRequest
  method: HTTPMethod
  endpoint: Content
  headers: Content ‚Üî Content
  body: ‚Ñô Content
  queryParams: Content ‚Üî Content
  timeout: ‚Ñï
where
  -- Endpoint must not be empty
  #endpoint > 0
  
  -- Timeout must be positive
  timeout > 0
  
  -- Optional body
  #body ‚â§ 1
  
  -- POST and PUT require body
  (method = POST ‚à® method = PUT) ‚áí body ‚â† ‚àÖ
end

-- API response structure
schema APIResponse
  status: HTTPStatus
  headers: Content ‚Üî Content
  body: ‚Ñô Content
  responseTime: ‚Ñï
  error: ‚Ñô Content
where
  -- Response time must be non-negative
  responseTime ‚â• 0
  
  -- Optional body and error
  #body ‚â§ 1
  #error ‚â§ 1
  
  -- Error responses should have error message
  status ‚àà {BAD_REQUEST, UNAUTHORIZED, FORBIDDEN, NOT_FOUND, SERVER_ERROR} ‚áí
    error ‚â† ‚àÖ
  
  -- Successful responses should have body
  status ‚àà {OK, CREATED} ‚áí body ‚â† ‚àÖ
end

--------------------------------------------------------------------------------
-- LLM SERVICE INTEGRATION
--------------------------------------------------------------------------------

-- LLM provider types
LLMProvider ::= OPENAI | ANTHROPIC | OLLAMA | CUSTOM

-- LLM request parameters
schema LLMRequest
  provider: LLMProvider
  model: Content
  prompt: Content
  systemPrompt: ‚Ñô Content
  temperature: ‚Ñù
  maxTokens: ‚Ñï
  stopSequences: seq Content
  topP: ‚Ñô ‚Ñù
  frequencyPenalty: ‚Ñô ‚Ñù
  presencePenalty: ‚Ñô ‚Ñù
where
  -- Model and prompt must not be empty
  #model > 0
  #prompt > 0
  
  -- Optional system prompt
  #systemPrompt ‚â§ 1
  
  -- Temperature must be in [0, 2] range
  0 ‚â§ temperature ‚â§ 2
  
  -- Max tokens must be positive
  maxTokens > 0
  
  -- Optional parameters must be in valid ranges
  topP ‚â† ‚àÖ ‚áí (‚àÉ p: ‚Ñù | topP = {p} ‚Ä¢ 0 ‚â§ p ‚â§ 1)
  frequencyPenalty ‚â† ‚àÖ ‚áí (‚àÉ f: ‚Ñù | frequencyPenalty = {f} ‚Ä¢ -2 ‚â§ f ‚â§ 2)
  presencePenalty ‚â† ‚àÖ ‚áí (‚àÉ p: ‚Ñù | presencePenalty = {p} ‚Ä¢ -2 ‚â§ p ‚â§ 2)
end

-- LLM response
schema LLMResponse
  content: Content
  finishReason: Content
  tokensUsed: ‚Ñï
  latency: ‚Ñï
  model: Content
  provider: LLMProvider
where
  -- Content must not be empty for successful responses
  finishReason = "stop" ‚áí #content > 0
  
  -- Tokens used must be non-negative
  tokensUsed ‚â• 0
  
  -- Latency must be non-negative
  latency ‚â• 0
end

-- Call LLM service operation
schema CallLLMService
  ŒîElizaOSSystemState
  request?: LLMRequest
  response!: LLMResponse ‚äé APIResponse
where
  -- Preconditions: none (external service)
  
  -- Successful response
  ‚àÉ llmResp: LLMResponse |
    llmResp.provider = request?.provider ‚àß
    llmResp.model = request?.model ‚Ä¢
    response! = inl llmResp
  
  ‚à®
  
  -- Error response
  ‚àÉ apiErr: APIResponse |
    apiErr.status = SERVER_ERROR ‚Ä¢
    response! = inr apiErr
  
  -- System state unchanged (read-only operation)
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

--------------------------------------------------------------------------------
-- EMBEDDING SERVICE INTEGRATION
--------------------------------------------------------------------------------

-- Embedding model types
EmbeddingModel ::= TEXT_EMBEDDING_ADA_002 | BERT | SENTENCE_TRANSFORMERS | CUSTOM

-- Embedding request
schema EmbeddingRequest
  model: EmbeddingModel
  texts: seq Content
  dimension: ‚Ñô ‚Ñï
where
  -- Must have at least one text
  #texts ‚â• 1
  
  -- All texts must be non-empty
  ‚àÄ t: ran texts ‚Ä¢ #t > 0
  
  -- Optional dimension specification
  #dimension ‚â§ 1
  dimension ‚â† ‚àÖ ‚áí (‚àÉ d: ‚Ñï | dimension = {d} ‚Ä¢ d > 0)
end

-- Embedding response
schema EmbeddingResponse
  embeddings: seq EmbeddingVector
  model: EmbeddingModel
  dimension: ‚Ñï
  tokensUsed: ‚Ñï
where
  -- Must have at least one embedding
  #embeddings ‚â• 1
  
  -- All embeddings must have same dimension
  ‚àÄ e: ran embeddings ‚Ä¢ #e = dimension
  
  -- Dimension must be positive
  dimension > 0
  
  -- Tokens used must be non-negative
  tokensUsed ‚â• 0
end

-- Generate embeddings operation
schema GenerateEmbeddings
  ŒîElizaOSSystemState
  request?: EmbeddingRequest
  response!: EmbeddingResponse ‚äé APIResponse
where
  -- Successful response
  ‚àÉ embResp: EmbeddingResponse |
    embResp.model = request?.model ‚àß
    #embResp.embeddings = #request?.texts ‚Ä¢
    response! = inl embResp
  
  ‚à®
  
  -- Error response
  ‚àÉ apiErr: APIResponse |
    apiErr.status = SERVER_ERROR ‚Ä¢
    response! = inr apiErr
  
  -- System state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

--------------------------------------------------------------------------------
-- VECTOR DATABASE INTEGRATION
--------------------------------------------------------------------------------

-- Vector DB operations
VectorDBOperation ::= INSERT | SEARCH | UPDATE | DELETE | CREATE_INDEX

-- Vector DB query
schema VectorDBQuery
  operation: VectorDBOperation
  collection: Content
  vectors: ‚Ñô (UUID √ó EmbeddingVector)
  queryVector: ‚Ñô EmbeddingVector
  topK: ‚Ñô ‚Ñï
  filter: ‚Ñô (Content ‚Üî Content)
where
  -- Collection must not be empty
  #collection > 0
  
  -- INSERT requires vectors
  operation = INSERT ‚áí vectors ‚â† ‚àÖ
  
  -- SEARCH requires query vector and topK
  operation = SEARCH ‚áí (queryVector ‚â† ‚àÖ ‚àß topK ‚â† ‚àÖ)
  
  -- TopK must be positive if present
  topK ‚â† ‚àÖ ‚áí (‚àÉ k: ‚Ñï | topK = {k} ‚Ä¢ k > 0)
end

-- Vector DB result
schema VectorDBResult
  operation: VectorDBOperation
  matches: seq (UUID √ó ‚Ñù)  -- ID and similarity score
  inserted: ‚Ñô ‚Ñï
  updated: ‚Ñô ‚Ñï
  deleted: ‚Ñô ‚Ñï
where
  -- SEARCH returns matches
  operation = SEARCH ‚áí #matches ‚â• 0
  
  -- INSERT returns count
  operation = INSERT ‚áí inserted ‚â† ‚àÖ
  
  -- UPDATE returns count
  operation = UPDATE ‚áí updated ‚â† ‚àÖ
  
  -- DELETE returns count
  operation = DELETE ‚áí deleted ‚â† ‚àÖ
  
  -- All similarity scores must be in [0, 1]
  ‚àÄ (_, score): ran matches ‚Ä¢ 0 ‚â§ score ‚â§ 1
end

-- Execute vector DB query operation
schema ExecuteVectorDBQuery
  ŒûElizaOSSystemState
  query?: VectorDBQuery
  result!: VectorDBResult ‚äé APIResponse
where
  -- Successful execution
  ‚àÉ dbResult: VectorDBResult |
    dbResult.operation = query?.operation ‚Ä¢
    result! = inl dbResult
  
  ‚à®
  
  -- Error response
  ‚àÉ apiErr: APIResponse ‚Ä¢
    result! = inr apiErr
end

--------------------------------------------------------------------------------
-- WEB AUTOMATION INTEGRATION
--------------------------------------------------------------------------------

-- Browser action types
BrowserAction ::= NAVIGATE | CLICK | TYPE | SCROLL | EXTRACT | SCREENSHOT

-- Browser automation request
schema BrowserRequest
  action: BrowserAction
  url: ‚Ñô Content
  selector: ‚Ñô Content
  inputText: ‚Ñô Content
  timeout: ‚Ñï
where
  -- NAVIGATE requires URL
  action = NAVIGATE ‚áí url ‚â† ‚àÖ
  
  -- CLICK and TYPE require selector
  (action = CLICK ‚à® action = TYPE) ‚áí selector ‚â† ‚àÖ
  
  -- TYPE requires input text
  action = TYPE ‚áí inputText ‚â† ‚àÖ
  
  -- Timeout must be positive
  timeout > 0
end

-- Browser automation response
schema BrowserResponse
  action: BrowserAction
  success: ùîπ
  extractedContent: ‚Ñô Content
  screenshotData: ‚Ñô (seq Byte)
  currentURL: ‚Ñô Content
  error: ‚Ñô Content
where
  -- Optional fields based on action
  action = EXTRACT ‚àß success ‚áí extractedContent ‚â† ‚àÖ
  action = SCREENSHOT ‚àß success ‚áí screenshotData ‚â† ‚àÖ
  
  -- Error must be present if not successful
  ¬¨success ‚áí error ‚â† ‚àÖ
end

-- Execute browser automation
schema ExecuteBrowserAction
  ŒîElizaOSSystemState
  request?: BrowserRequest
  response!: BrowserResponse
where
  -- Execute action and get response
  ‚àÉ resp: BrowserResponse |
    resp.action = request?.action ‚Ä¢
    response! = resp
  
  -- Optionally store extracted content in memory
  resp.extractedContent ‚â† ‚àÖ ‚áí
    ‚àÉ memory: Memory |
      memory.content = ‚ãÉ resp.extractedContent ‚Ä¢
      -- Create memory operation would be invoked here
      true
  
  -- Other state may be updated if storing results
  agents' = agents ‚à® agents' ‚â† agents
  memorySystem' = memorySystem ‚à® memorySystem' ‚â† memorySystem
  agentLoops' = agentLoops
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

--------------------------------------------------------------------------------
-- WEBHOOK AND EVENT HANDLER INTEGRATION
--------------------------------------------------------------------------------

-- Event types
EventType ::= WEBHOOK | MESSAGE_RECEIVED | TASK_COMPLETED | 
              AGENT_STATUS_CHANGE | MEMORY_CREATED

-- Event payload
schema EventPayload
  eventType: EventType
  timestamp: Timestamp
  source: Content
  data: Content ‚Üî Content
  signature: ‚Ñô Content
where
  -- Timestamp must be non-negative
  timestamp ‚â• 0
  
  -- Source must not be empty
  #source > 0
  
  -- Optional signature for authentication
  #signature ‚â§ 1
end

-- Event validation result
schema EventValidation
  valid: ùîπ
  reason: ‚Ñô Content
  authenticatedSource: ‚Ñô Content
where
  -- If invalid, must have reason
  ¬¨valid ‚áí reason ‚â† ‚àÖ
  
  -- If valid and has signature, should have authenticated source
  valid ‚àß authenticatedSource = ‚àÖ ‚áí true
end

-- Validate event
schema ValidateEvent
  ŒûElizaOSSystemState
  payload?: EventPayload
  validation!: EventValidation
where
  -- Check signature if present
  payload?.signature ‚â† ‚àÖ ‚áí
    ‚àÉ auth: Content |
      auth = VerifySignature(payload?.signature, payload?.data) ‚Ä¢
      validation!.authenticatedSource = {auth}
  
  -- Validate event structure
  validation!.valid ‚áî 
    (payload?.timestamp ‚â• 0 ‚àß #(payload?.source) > 0)
end

-- Handle incoming event
schema HandleEvent
  ŒîElizaOSSystemState
  payload?: EventPayload
  result!: ùîπ
where
  -- Precondition: event must be valid
  ‚àÉ validation: EventValidation |
    validation = ValidateEvent(payload?) ‚Ä¢
    validation.valid = true
  
  -- Process event based on type
  payload?.eventType = WEBHOOK ‚áí
    -- Process webhook data
    result! = true
  
  payload?.eventType = MESSAGE_RECEIVED ‚áí
    -- Create message in communication system
    ‚àÉ message: Message |
      message.content = (payload?.data)("content") ‚Ä¢
      SendMessage‚ü®message? := message‚ü©
  
  payload?.eventType = TASK_COMPLETED ‚áí
    -- Update task status
    ‚àÉ taskId: UUID |
      taskId = UUID((payload?.data)("taskId")) ‚Ä¢
      CompleteTask‚ü®taskId? := taskId‚ü©
  
  payload?.eventType = AGENT_STATUS_CHANGE ‚áí
    -- Update agent status
    result! = true
  
  payload?.eventType = MEMORY_CREATED ‚áí
    -- Process new memory notification
    result! = true
end

--------------------------------------------------------------------------------
-- ERROR HANDLING AND RETRY LOGIC
--------------------------------------------------------------------------------

-- Retry policy
schema RetryPolicy
  maxRetries: ‚Ñï
  initialDelay: ‚Ñï
  maxDelay: ‚Ñï
  backoffMultiplier: ‚Ñù
  retryableErrors: ‚Ñô HTTPStatus
where
  -- Max retries must be non-negative
  maxRetries ‚â• 0
  
  -- Delays must be positive
  initialDelay > 0
  maxDelay > initialDelay
  
  -- Backoff multiplier must be >= 1
  backoffMultiplier ‚â• 1.0
end

-- Retry state
schema RetryState
  attemptCount: ‚Ñï
  lastAttemptTime: Timestamp
  nextRetryTime: Timestamp
  cumulativeDelay: ‚Ñï
  lastError: ‚Ñô Content
where
  -- Attempt count must be non-negative
  attemptCount ‚â• 0
  
  -- Times must be ordered
  lastAttemptTime ‚â§ nextRetryTime
  
  -- Cumulative delay must be non-negative
  cumulativeDelay ‚â• 0
end

-- Execute with retry
schema ExecuteWithRetry[Request, Response]
  ŒûElizaOSSystemState
  request?: Request
  policy?: RetryPolicy
  response!: Response ‚äé APIResponse
  retryState!: RetryState
where
  -- Attempt execution
  attemptCount: ‚Ñï
  attemptCount ‚â§ policy?.maxRetries
  
  -- Calculate delay for current attempt
  ‚àÉ delay: ‚Ñï |
    delay = min(
      policy?.initialDelay * (policy?.backoffMultiplier ^ attemptCount),
      policy?.maxDelay
    ) ‚Ä¢
    retryState!.cumulativeDelay = 
      retryState!.cumulativeDelay + delay
  
  -- Try operation
  (response! = inl _ ‚áí retryState!.attemptCount = attemptCount) ‚à®
  (response! = inr _ ‚àß attemptCount < policy?.maxRetries ‚áí
    retryState!.attemptCount = attemptCount + 1)
end

--------------------------------------------------------------------------------
-- RATE LIMITING
--------------------------------------------------------------------------------

-- Rate limit configuration
schema RateLimitConfig
  requestsPerSecond: ‚Ñù
  burstSize: ‚Ñï
  timeWindow: ‚Ñï
where
  -- Requests per second must be positive
  requestsPerSecond > 0
  
  -- Burst size must be positive
  burstSize > 0
  
  -- Time window must be positive (in seconds)
  timeWindow > 0
end

-- Rate limit state
schema RateLimitState
  requestCount: ‚Ñï
  windowStart: Timestamp
  tokensAvailable: ‚Ñù
  lastRefillTime: Timestamp
where
  -- Request count must be non-negative
  requestCount ‚â• 0
  
  -- Tokens available must be non-negative
  tokensAvailable ‚â• 0
  
  -- Times must be ordered
  windowStart ‚â§ lastRefillTime
end

-- Check rate limit
schema CheckRateLimit
  ŒûElizaOSSystemState
  config?: RateLimitConfig
  state?: RateLimitState
  currentTime?: Timestamp
  allowed!: ùîπ
  newState!: RateLimitState
where
  -- Refill tokens based on time elapsed
  ‚àÉ timeElapsed: ‚Ñù; tokensToAdd: ‚Ñù |
    timeElapsed = (currentTime? - state?.lastRefillTime) / 1000.0 ‚àß
    tokensToAdd = timeElapsed * config?.requestsPerSecond ‚àß
    newState!.tokensAvailable = 
      min(state?.tokensAvailable + tokensToAdd, config?.burstSize) ‚Ä¢
    
    -- Check if request is allowed
    newState!.tokensAvailable ‚â• 1.0 ‚áí
      (allowed! = true ‚àß
       newState!.tokensAvailable = state?.tokensAvailable - 1.0) ‚àß
    newState!.tokensAvailable < 1.0 ‚áí
      (allowed! = false ‚àß
       newState!.tokensAvailable = state?.tokensAvailable)
  
  -- Update timestamps
  newState!.lastRefillTime = currentTime?
  allowed! ‚áí newState!.requestCount = state?.requestCount + 1
end

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

-- Verify cryptographic signature
VerifySignature: ‚Ñô Content √ó (Content ‚Üî Content) ‚Üí Content

-- Convert string to UUID
UUID: Content ‚Üí UUID

-- Calculate exponential backoff delay
CalculateBackoff: ‚Ñï √ó ‚Ñï √ó ‚Ñù √ó ‚Ñï ‚Üí ‚Ñï

--------------------------------------------------------------------------------
-- INTEGRATION INVARIANTS
--------------------------------------------------------------------------------

-- External service health tracking
schema ExternalServiceHealth
  serviceName: Content
  isHealthy: ùîπ
  lastSuccessTime: ‚Ñô Timestamp
  lastFailureTime: ‚Ñô Timestamp
  consecutiveFailures: ‚Ñï
  totalRequests: ‚Ñï
  successfulRequests: ‚Ñï
  failedRequests: ‚Ñï
where
  -- Service name must not be empty
  #serviceName > 0
  
  -- Consecutive failures must be non-negative
  consecutiveFailures ‚â• 0
  
  -- Request counts must be consistent
  totalRequests = successfulRequests + failedRequests
  
  -- Healthy if no recent failures
  consecutiveFailures = 0 ‚áí isHealthy = true
  consecutiveFailures > 5 ‚áí isHealthy = false
end

-- Circuit breaker state
schema CircuitBreakerState
  serviceName: Content
  state: Content  -- "CLOSED", "OPEN", "HALF_OPEN"
  failureCount: ‚Ñï
  lastFailureTime: ‚Ñô Timestamp
  nextRetryTime: ‚Ñô Timestamp
where
  -- State must be valid
  state ‚àà {"CLOSED", "OPEN", "HALF_OPEN"}
  
  -- Failure count must be non-negative
  failureCount ‚â• 0
  
  -- OPEN state requires next retry time
  state = "OPEN" ‚áí nextRetryTime ‚â† ‚àÖ
  
  -- CLOSED state means no failures
  state = "CLOSED" ‚áí failureCount = 0
end

--------------------------------------------------------------------------------
-- END OF INTEGRATION CONTRACTS SPECIFICATION
--------------------------------------------------------------------------------

-- This specification defines all external system integration contracts
-- for ElizaOS C++, including API interactions, event handling, error
-- management, and rate limiting. These contracts ensure reliable and
-- predictable interactions with external services.
