--------------------------------------------------------------------------------
-- ElizaOS C++ Operations Formal Specification
-- Z++ Specification Language
-- Version: 1.0.0
-- Date: December 12, 2024
--------------------------------------------------------------------------------

-- This specification formalizes the operations of the ElizaOS C++ framework,
-- including state transformations, preconditions, and postconditions.

-- Import previous specifications
-- include data_model.zpp
-- include system_state.zpp

--------------------------------------------------------------------------------
-- AGENT LIFECYCLE OPERATIONS
--------------------------------------------------------------------------------

-- Create a new agent
schema CreateAgent
  ŒîElizaOSSystemState
  config?: AgentConfig
  agentId!: AgentId
where
  -- Preconditions
  config?.agentId ‚àâ dom agents
  
  -- Create new agent state
  ‚àÉ newAgentState: AgentState | 
    newAgentState.config = config? ‚àß
    newAgentState.status = IDLE ‚àß
    newAgentState.currentMemories = ‚ü®‚ü© ‚àß
    newAgentState.actors = ‚ü®‚ü© ‚àß
    newAgentState.goals = ‚ü®‚ü© ‚àß
    newAgentState.recentMessages = ‚ü®‚ü© ‚àß
    newAgentState.characterProfile = ‚àÖ ‚àß
    newAgentState.conversationContexts = ‚àÖ ‚àß
    newAgentState.knowledgeReferences = ‚àÖ ‚àß
    newAgentState.activeTaskIds = ‚àÖ ‚àß
    newAgentState.cognitiveLoad = 0.0 ‚àß
    newAgentState.attentionFocus = ‚àÖ ‚Ä¢
    
    agents' = agents ‚à™ {config?.agentId ‚Ü¶ newAgentState}
  
  -- Output agent ID
  agentId! = config?.agentId
  
  -- Other state unchanged
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

-- Start agent loop
schema StartAgentLoop
  ŒîElizaOSSystemState
  agentId?: AgentId
  steps?: ‚Ñï
  interval?: ‚Ñù
where
  -- Preconditions
  agentId? ‚àà dom agents
  steps? > 0
  interval? ‚â• 0
  
  -- Create or update agent loop state
  ‚àÉ loopState: AgentLoopState |
    loopState.agentId = agentId? ‚àß
    loopState.running = true ‚àß
    loopState.paused = false ‚àß
    loopState.stepIndex = 0 ‚àß
    loopState.totalSteps = steps? ‚àß
    loopState.intervalSeconds = interval? ‚àß
    loopState.errorCount = 0 ‚àß
    loopState.executionHistory = ‚ü®‚ü© ‚Ä¢
    
    agentLoops' = agentLoops ‚äï {agentId? ‚Ü¶ loopState}
  
  -- Increment thread count
  threadCount' = threadCount + 1
  
  -- Other state unchanged
  agents' = agents
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

-- Stop agent loop
schema StopAgentLoop
  ŒîElizaOSSystemState
  agentId?: AgentId
where
  -- Preconditions
  agentId? ‚àà dom agentLoops
  (agentLoops(agentId?)).running = true
  
  -- Update loop state
  agentLoops' = agentLoops ‚äï 
    {agentId? ‚Ü¶ (agentLoops(agentId?))‚ü®running := false‚ü©}
  
  -- Decrement thread count
  threadCount' = threadCount - 1
  
  -- Other state unchanged
  agents' = agents
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

--------------------------------------------------------------------------------
-- MEMORY OPERATIONS
--------------------------------------------------------------------------------

-- Create a new memory
schema CreateMemory
  ŒîElizaOSSystemState
  memory?: Memory
  tableName?: Content
  unique?: ùîπ
  memoryId!: UUID
where
  -- Preconditions
  tableName? ‚àà dom (memorySystem.tables)
  #(memory?.content) > 0
  
  -- If unique, check for duplicates
  unique? ‚áí 
    ‚àÄ m: ran (((memorySystem.tables)(tableName?)).memories) ‚Ä¢
      m.content ‚â† memory?.content ‚à® m.entityId ‚â† memory?.entityId
  
  -- Add memory to table
  ‚àÉ table: MemoryTableState |
    table = (memorySystem.tables)(tableName?) ‚àß
    memory?.id ‚àâ dom (table.memories) ‚Ä¢
    
    memorySystem' = memorySystem‚ü®
      tables := (memorySystem.tables) ‚äï 
        {tableName? ‚Ü¶ table‚ü®
          memories := table.memories ‚à™ {memory?.id ‚Ü¶ memory?}
        ‚ü©},
      totalMemories := memorySystem.totalMemories + 1
    ‚ü©
  
  -- Output memory ID
  memoryId! = memory?.id
  
  -- Increment total memories created
  totalMemoriesCreated' = totalMemoriesCreated + 1
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

-- Retrieve memory by ID
schema GetMemoryById
  ŒûElizaOSSystemState
  memoryId?: UUID
  tableName?: Content
  memory!: ‚Ñô Memory
where
  -- Preconditions
  tableName? ‚àà dom (memorySystem.tables)
  
  -- Retrieve memory if exists
  memoryId? ‚àà dom (((memorySystem.tables)(tableName?)).memories) ‚áí
    memory! = {(((memorySystem.tables)(tableName?)).memories)(memoryId?)}
  
  -- Return empty if not found
  memoryId? ‚àâ dom (((memorySystem.tables)(tableName?)).memories) ‚áí
    memory! = ‚àÖ
end

-- Search memories by embedding similarity
schema SearchMemoriesByEmbedding
  ŒûElizaOSSystemState
  embedding?: EmbeddingVector
  tableName?: Content
  threshold?: ‚Ñù
  limit?: ‚Ñï
  results!: seq Memory
where
  -- Preconditions
  tableName? ‚àà dom (memorySystem.tables)
  #embedding? = memorySystem.embeddingDimension
  0 ‚â§ threshold? ‚â§ 1
  limit? > 0
  
  -- Find similar memories
  ‚àÉ candidates: ‚Ñô (Memory √ó ‚Ñù) |
    -- For each memory with embedding, compute similarity
    candidates = {m: Memory; sim: ‚Ñù |
      ‚àÉ mid: dom (((memorySystem.tables)(tableName?)).memories) ‚Ä¢
        m = (((memorySystem.tables)(tableName?)).memories)(mid) ‚àß
        m.embedding ‚â† ‚àÖ ‚àß
        sim = CosineSimilarity(embedding?, ‚ãÉ m.embedding) ‚àß
        sim ‚â• threshold?
    } ‚Ä¢
    
    -- Sort by similarity (descending) and take top limit?
    results! = TakeTop(SortBySimilarity(candidates), limit?)
end

-- Delete memory
schema DeleteMemory
  ŒîElizaOSSystemState
  memoryId?: UUID
  tableName?: Content
where
  -- Preconditions
  tableName? ‚àà dom (memorySystem.tables)
  memoryId? ‚àà dom (((memorySystem.tables)(tableName?)).memories)
  
  -- Remove memory from table
  ‚àÉ table: MemoryTableState |
    table = (memorySystem.tables)(tableName?) ‚Ä¢
    
    memorySystem' = memorySystem‚ü®
      tables := (memorySystem.tables) ‚äï 
        {tableName? ‚Ü¶ table‚ü®
          memories := {memoryId?} ‚©§ table.memories
        ‚ü©},
      totalMemories := memorySystem.totalMemories - 1
    ‚ü©
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

--------------------------------------------------------------------------------
-- COMMUNICATION OPERATIONS
--------------------------------------------------------------------------------

-- Register an agent in the communication system
schema RegisterAgent
  ŒîElizaOSSystemState
  agentId?: AgentId
where
  -- Preconditions
  agentId? ‚àà dom agents
  agentId? ‚àâ dom (communicationSystem.agents)
  
  -- Create participation state
  ‚àÉ participation: AgentParticipationState |
    participation.agentId = agentId? ‚àß
    participation.subscribedServers = ‚àÖ ‚àß
    participation.subscribedChannels = ‚àÖ ‚àß
    participation.unreadMessages = ‚àÖ ‚Ä¢
    
    communicationSystem' = communicationSystem‚ü®
      agents := communicationSystem.agents ‚à™ {agentId? ‚Ü¶ participation}
    ‚ü©
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

-- Send a message
schema SendMessage
  ŒîElizaOSSystemState
  message?: Message
  messageId!: UUID
where
  -- Preconditions
  message?.sender ‚àà dom (communicationSystem.agents)
  message?.receiver ‚àà dom (communicationSystem.agents)
  message?.channelId ‚àà dom (communicationSystem.channels)
  #(message?.content) > 0
  
  -- Add to message archive
  communicationSystem' = communicationSystem‚ü®
    messageArchive := communicationSystem.messageArchive ‚à™ 
      {message?.id ‚Ü¶ message?},
    pendingMessages := communicationSystem.pendingMessages ‚ÅÄ ‚ü®message?‚ü©
  ‚ü©
  
  -- Output message ID
  messageId! = message?.id
  
  -- Increment total messages
  totalProcessedMessages' = totalProcessedMessages + 1
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

-- Broadcast message to channel
schema BroadcastMessage
  ŒîElizaOSSystemState
  message?: Message
  channelId?: ChannelId
where
  -- Preconditions
  channelId? ‚àà dom (communicationSystem.channels)
  message?.sender ‚àà dom (communicationSystem.agents)
  
  -- Add message to channel queue
  ‚àÉ channel: ChannelState |
    channel = (communicationSystem.channels)(channelId?) ‚Ä¢
    
    communicationSystem' = communicationSystem‚ü®
      channels := communicationSystem.channels ‚äï
        {channelId? ‚Ü¶ channel‚ü®
          messageQueue := channel.messageQueue ‚ÅÄ ‚ü®message?‚ü©,
          messageHistory := channel.messageHistory ‚ÅÄ ‚ü®message?.id‚ü©
        ‚ü©},
      messageArchive := communicationSystem.messageArchive ‚à™ 
        {message?.id ‚Ü¶ message?}
    ‚ü©
  
  -- Increment total messages
  totalProcessedMessages' = totalProcessedMessages + 1
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

--------------------------------------------------------------------------------
-- CONVERSATION OPERATIONS
--------------------------------------------------------------------------------

-- Process message with Eliza engine
schema ProcessMessage
  ŒîElizaOSSystemState
  agentId?: AgentId
  input?: Content
  sessionId?: UUID
  response!: Content
where
  -- Preconditions
  agentId? ‚àà dom agents
  #input? > 0
  
  -- Get or create conversation context
  ‚àÉ agent: AgentState; context: ConversationContext |
    agent = agents(agentId?) ‚àß
    (sessionId? ‚àà dom (agent.conversationContexts) ‚áí
      context = (agent.conversationContexts)(sessionId?)) ‚àß
    (sessionId? ‚àâ dom (agent.conversationContexts) ‚áí
      context.sessionId = sessionId? ‚àß
      context.history = ‚ü®‚ü©) ‚Ä¢
    
    -- Generate response based on character and history
    ‚àÉ turn: ConversationTurn; responseText: Content |
      turn.input = input? ‚àß
      turn.response = responseText ‚àß
      responseText = GenerateResponse(agent, context, input?) ‚Ä¢
      
      -- Update agent state with new context
      agents' = agents ‚äï {agentId? ‚Ü¶ agent‚ü®
        conversationContexts := agent.conversationContexts ‚äï
          {sessionId? ‚Ü¶ context‚ü®
            history := context.history ‚ÅÄ ‚ü®turn‚ü©
          ‚ü©}
      ‚ü©} ‚àß
      response! = responseText
  
  -- Other state unchanged
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

--------------------------------------------------------------------------------
-- TASK OPERATIONS
--------------------------------------------------------------------------------

-- Create a new task
schema CreateTask
  ŒîElizaOSSystemState
  name?: Content
  description?: Content
  priority?: ‚Ñï
  taskId!: UUID
where
  -- Preconditions
  #name? > 0
  priority? ‚â• 0
  
  -- Create new task
  ‚àÉ newTask: Task; newId: UUID |
    newTask.id = newId ‚àß
    newTask.name = name? ‚àß
    newTask.description = {description?} ‚àß
    newTask.status = PENDING ‚àß
    newTask.priority = priority? ‚àß
    newTask.dependencies = ‚ü®‚ü© ‚àß
    newId ‚àâ dom (taskManager.tasks) ‚Ä¢
    
    taskManager' = taskManager‚ü®
      tasks := taskManager.tasks ‚à™ {newId ‚Ü¶ newTask},
      tasksByStatus := taskManager.tasksByStatus ‚äï
        {PENDING ‚Ü¶ (taskManager.tasksByStatus)(PENDING) ‚à™ {newId}},
      totalTasks := taskManager.totalTasks + 1
    ‚ü© ‚àß
    taskId! = newId
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
end

-- Start task execution
schema StartTask
  ŒîElizaOSSystemState
  taskId?: UUID
where
  -- Preconditions
  taskId? ‚àà dom (taskManager.tasks)
  (taskManager.tasks(taskId?)).status = PENDING
  
  -- Check dependencies are completed
  ‚àÄ depId: ran ((taskManager.tasks(taskId?)).dependencies) ‚Ä¢
    depId ‚àà taskManager.completedTasks
  
  -- Update task status
  ‚àÉ task: Task |
    task = (taskManager.tasks)(taskId?) ‚Ä¢
    
    taskManager' = taskManager‚ü®
      tasks := taskManager.tasks ‚äï 
        {taskId? ‚Ü¶ task‚ü®status := IN_PROGRESS‚ü©},
      tasksByStatus := taskManager.tasksByStatus ‚äï
        {PENDING ‚Ü¶ (taskManager.tasksByStatus)(PENDING) \ {taskId?},
         IN_PROGRESS ‚Ü¶ (taskManager.tasksByStatus)(IN_PROGRESS) ‚à™ {taskId?}},
      executingTasks := taskManager.executingTasks ‚à™ {taskId?}
    ‚ü©
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
end

-- Complete task
schema CompleteTask
  ŒîElizaOSSystemState
  taskId?: UUID
  completionTime?: Timestamp
where
  -- Preconditions
  taskId? ‚àà dom (taskManager.tasks)
  (taskManager.tasks(taskId?)).status = IN_PROGRESS
  completionTime? ‚â• (taskManager.tasks(taskId?)).createdAt
  
  -- Update task status
  ‚àÉ task: Task |
    task = (taskManager.tasks)(taskId?) ‚Ä¢
    
    taskManager' = taskManager‚ü®
      tasks := taskManager.tasks ‚äï 
        {taskId? ‚Ü¶ task‚ü®
          status := COMPLETED,
          completedAt := {completionTime?}
        ‚ü©},
      tasksByStatus := taskManager.tasksByStatus ‚äï
        {IN_PROGRESS ‚Ü¶ (taskManager.tasksByStatus)(IN_PROGRESS) \ {taskId?},
         COMPLETED ‚Ü¶ (taskManager.tasksByStatus)(COMPLETED) ‚à™ {taskId?}},
      executingTasks := taskManager.executingTasks \ {taskId?},
      completedTasks := taskManager.completedTasks ‚à™ {taskId?}
    ‚ü©
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  hypergraph' = hypergraph
end

--------------------------------------------------------------------------------
-- KNOWLEDGE OPERATIONS
--------------------------------------------------------------------------------

-- Add knowledge entry
schema AddKnowledgeEntry
  ŒîElizaOSSystemState
  content?: Content
  category?: Content
  entryId!: UUID
where
  -- Preconditions
  #content? > 0
  #category? > 0
  
  -- Create new entry
  ‚àÉ newEntry: KnowledgeEntry; newId: UUID |
    newEntry.id = newId ‚àß
    newEntry.content = content? ‚àß
    newEntry.category = category? ‚àß
    newEntry.references = ‚ü®‚ü© ‚àß
    newEntry.accessCount = 0 ‚àß
    newEntry.lastAccessed = ‚àÖ ‚àß
    newId ‚àâ dom (knowledgeSystem.entries) ‚Ä¢
    
    knowledgeSystem' = knowledgeSystem‚ü®
      entries := knowledgeSystem.entries ‚à™ {newId ‚Ü¶ newEntry},
      categoryIndex := knowledgeSystem.categoryIndex ‚äï
        {category? ‚Ü¶ (knowledgeSystem.categoryIndex)(category?) ‚à™ {newId}},
      totalEntries := knowledgeSystem.totalEntries + 1
    ‚ü© ‚àß
    entryId! = newId
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  hypergraph' = hypergraph
  taskManager' = taskManager
end

-- Query knowledge by category
schema QueryKnowledgeByCategory
  ŒûElizaOSSystemState
  category?: Content
  results!: seq KnowledgeEntry
where
  -- Preconditions
  category? ‚àà dom (knowledgeSystem.categoryIndex)
  
  -- Retrieve all entries in category
  results! = [e: KnowledgeEntry | 
    e.id ‚àà (knowledgeSystem.categoryIndex)(category?) ‚àß
    e = (knowledgeSystem.entries)(e.id)]
end

--------------------------------------------------------------------------------
-- ATTENTION ALLOCATION OPERATIONS
--------------------------------------------------------------------------------

-- Update attention values (ECAN-inspired)
schema UpdateAttention
  ŒîElizaOSSystemState
  focusedIds?: ‚Ñô UUID
  decayFactor?: ‚Ñù
where
  -- Preconditions
  0 < decayFactor? < 1
  
  -- Decay all STI values
  ‚àÄ nid: dom (hypergraph.nodes) ‚Ä¢
    hypergraph' = hypergraph‚ü®
      nodes := hypergraph.nodes ‚äï
        {nid ‚Ü¶ (hypergraph.nodes(nid))‚ü®
          sti := (hypergraph.nodes(nid)).sti * decayFactor?
        ‚ü©}
    ‚ü©
  
  -- Boost STI for focused nodes
  ‚àÄ fid: focusedIds? | fid ‚àà dom (hypergraph.nodes) ‚Ä¢
    hypergraph' = hypergraph'‚ü®
      nodes := hypergraph'.nodes ‚äï
        {fid ‚Ü¶ (hypergraph'.nodes(fid))‚ü®
          sti := min((hypergraph'.nodes(fid)).sti + 10.0, 100.0)
        ‚ü©}
    ‚ü©
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  taskManager' = taskManager
end

-- Forget low-attention nodes
schema ForgetLowAttention
  ŒîElizaOSSystemState
where
  -- Find nodes below forgetting threshold
  ‚àÉ toForget: ‚Ñô UUID |
    toForget = {nid: UUID | 
      nid ‚àà dom (hypergraph.nodes) ‚àß
      (hypergraph.nodes(nid)).sti < hypergraph.forgettingThreshold
    } ‚Ä¢
    
    hypergraph' = hypergraph‚ü®
      nodes := toForget ‚©§ hypergraph.nodes,
      totalNodes := hypergraph.totalNodes - #toForget
    ‚ü©
  
  -- Remove edges referencing forgotten nodes
  ‚àÉ invalidEdges: ‚Ñô UUID |
    invalidEdges = {eid: UUID |
      eid ‚àà dom (hypergraph.edges) ‚àß
      ‚àÉ nid: ran ((hypergraph.edges(eid)).nodeIds) ‚Ä¢
        nid ‚àâ dom (hypergraph'.nodes)
    } ‚Ä¢
    
    hypergraph' = hypergraph'‚ü®
      edges := invalidEdges ‚©§ hypergraph'.edges,
      totalEdges := hypergraph'.totalEdges - #invalidEdges
    ‚ü©
  
  -- Other state unchanged
  agents' = agents
  agentLoops' = agentLoops
  memorySystem' = memorySystem
  communicationSystem' = communicationSystem
  knowledgeSystem' = knowledgeSystem
  taskManager' = taskManager
end

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS (Axiomatic Definitions)
--------------------------------------------------------------------------------

-- Cosine similarity between two embedding vectors
CosineSimilarity: EmbeddingVector √ó EmbeddingVector ‚Üí ‚Ñù

‚àÄ v1, v2: EmbeddingVector | #v1 = #v2 ‚Ä¢
  CosineSimilarity(v1, v2) = 
    (Œ£ i: 1..#v1 ‚Ä¢ v1(i) * v2(i)) /
    (sqrt(Œ£ i: 1..#v1 ‚Ä¢ v1(i)¬≤) * sqrt(Œ£ i: 1..#v2 ‚Ä¢ v2(i)¬≤))

-- Generate response based on agent state and context
GenerateResponse: AgentState √ó ConversationContext √ó Content ‚Üí Content

-- Sort candidates by similarity score
SortBySimilarity: ‚Ñô (Memory √ó ‚Ñù) ‚Üí seq Memory

-- Take top N results
TakeTop: seq Memory √ó ‚Ñï ‚Üí seq Memory

--------------------------------------------------------------------------------
-- END OF OPERATIONS SPECIFICATION
--------------------------------------------------------------------------------

-- This specification defines all major operations in ElizaOS C++,
-- including their preconditions, postconditions, and state transformations.
-- Integration operations with external systems are defined in integrations.zpp.
